


r=(;fe=3,re=1)
q=randn(4,5)
using Boilerplate
@typeof (4f0,q,r)
fn(a,q,r) = (println("ok");return a+6f0)
fnn(a,q,r) = (println("ok");return a+6f0)
tt = (typeof((4f0,q,r)))
@show tt
qq=4f0
@show @typed_memo Float32 fn(qq,q,r)
@show @typed_memo Float32 fn(qq,q,r)
@show @typed_memo Float32 fn(qq,q,r)
@show @typed_memo Float32 fnn(qq,q,r)
@show @typed_memo Float32 fnn(qq,q,r)
@show @typed_memo Float32 fnn(qq,q,r)

#%%
gettype(f, args...) = last(@code_typed f(args...))

macro memoize_tsafe(outtype,funccall)
    _memoize_funccall(outtype,funccall)
end
function _memoize_funccall(outtype,funccall)
    funcname = funccall.args[1]
    # @show funccall.args[2:end]
    # args_tsafe = tuple(funccall.args[i] for i in 2:length(funccall.args))
    args_tsafe = tuple(funccall.args[2:end]...)
    # @show args_tsafe
    esc(_memoized_call(outtype,funcname, funccall, args_tsafe))
end


# function _memoized_call(fn_name, fn_body, args)
function _memoized_call(out_type, fn_name, fn_body, args)
    cache_funcname = Symbol("$(fn_name)_cached")
    quote
		!@isdefined($cache_funcname) && ($cache_funcname=Dict{typeof($args),$out_type}())
        if $args in keys($cache_funcname) 
            $cache_funcname[$args]
        else
            $cache_funcname[$args] = $fn_body
        end
        # input_type = typeof($args)
        # out_type = Core.Compiler.return_type($fn_body, input_type)
        # out_type = gettype($fn_body, $args...)
        # @show out_type
        # @show "okkkk"
        # if !isconcretetype(out_type)
        #     @warn("return type does not infer to a concrete type: $out_type")
        # end
		# $(cache_funcname)=Dict{input_type,out_type}()
        # $T = $(Core.Compiler.return_type)($getter, $Tuple{})
    end
end

r=(;fe=3,re=1)
q=randn(4,5)
using Boilerplate
@typeof (4f0,q,r)
fn(a,q,r) = (println("ok");return a+6f0)
tt = (typeof((4f0,q,r)))
@show tt
qq=4f0
@memoize_tsafe Float32 fn(qq,q,r)
@show fn_cached
@typeof fn_cached
# macro cachelayer(key_type, typedef) 
# 	tn = typename(typedef)
# 	tn_cached = Symbol("$(tn)_cached")
# 	obj=:obj
# 	uniquekey=:uniquekey
# 	is_cached=:is_cached
# 	load=:load
# 	load_data=:load_data

# 	load_data_unimp_msg = "load_data(obj::$tn) is unimplemented cache layer interface method"
# 	uniquekey_unimp_msg = "uniquekey(obj::$tn) is unimplemented cache layer interface method"
# 	# println(tn)
# 	# println(tn_cached)
# 	return esc(quote 
# 		$typedef
# 		# esc(tn)=Dict()
# 		$(tn_cached)=Dict{$((key_type)),$((tn))}()

# 		$is_cached($obj::$tn) = $(uniquekey)($obj) in keys($tn_cached) 
# 		$load($obj::$tn)      = if $is_cached($obj); return $tn_cached[$(uniquekey)($obj)]
# 																				else                 return $tn_cached[$(uniquekey)($obj)] = $load_data($obj)
# 																				end
		
# 		$uniquekey($obj::$tn) = error($uniquekey_unimp_msg)
# 		$load_data($obj::$tn) = error($load_data_unimp_msg)
# 	end)
# end
#%%



using MacroTools: splitdef, combinedef, splitarg, combinearg, isexpr


# We memoize in two different ways:
# * For "statically" memoizable functions (just top-level functions
#   for now), each function's cache is stored inside a `@generated`
#   function specific to that top-level function, so there is no
#   overhead for looking up the cache
# * For closures and callables, in the `dynamic_caches` IdDict below.
statically_memoizable(::Type{F}) where {F} = isdefined(F, :instance)

# A mapping (func => cache) for each memoized closure or callable
const dynamic_caches = IdDict()

# Lookup `func` in `caches`, and create its cache if its not there.
_dynamic_get_cache(default, func) = _get!(default, dynamic_caches, func)

# each statically memoizable function will define a method of this
# specific to itself
_static_get_cache(::Any) = nothing

# this is the method called by the code generated by `@memoize`, which
# doesnt know if its static or dynamic lookup. note, the branch here
# should be optimized away since whether there is a
# `_static_get_cache` is known at compile time, so no extra overhead
# for statically memoizable things
function get_cache(default, func) 
    cache = _static_get_cache(func)
    cache !== nothing ? cache : _dynamic_get_cache(default, func)
end

# A mapping (func => cache_constructor_expr) for each
# memoized function `func`, so that we can verify the same expression
# is always used.
const cache_constructor_exprs = IdDict()


# get all memoization caches in the current session. this includes
# caches in `dynamic_caches` and all the caches in the specialized
# `_static_get_cache` for each statically memoized function. note, the
# `_dummy_backedge` thing is to trigger recompilation of this function
# on startup. for some reason, it otherwise sporadically seems to not
# dispatch to the right `_static_get_cache` for memoized functions
# that got called during precompilation. seems like a Julia bug, but
# not sure.
_dummy_backedge() = nothing
function get_caches()
    _dummy_backedge()
    caches = IdDict()
    merge!(caches, dynamic_caches)
    generic_static_get_cache = which(_static_get_cache, Tuple{Any})
    for m in methods(_static_get_cache)
        if m != generic_static_get_cache
            func = m.sig.parameters[2]
            caches[func.instance] = _static_get_cache(func.instance)
        end
    end
    caches
end
function __init__()
    if ccall(:jl_generating_output, Cint, ()) == 0
        @eval _dummy_backedge() = nothing
    end
end



"""
    empty_cache!(arg)
    
Empties the memoization cache for functions, closures, or callables.
    
For functions or closures, `arg` should be the name of the function or closure.
For callables, `arg` should be a type and the cache for all callable objects
matching that type will be cleared.
"""
empty_cache!(func) = map(empty!, values(find_caches(func)))
find_caches(func::F) where {F<:Function} = 
    filter(((func′,_),)->(statically_memoizable(F) ? (func′ == func) : (func′ == F)), get_caches())
find_caches(F::Union{DataType,Union,UnionAll}) = 
    filter(((func′,_),)->(func′ isa F), get_caches())
empty_all_caches!() = map(empty!, values(get_caches()))

"""
    @memoize f(x) = ...                # memoize a function definition
    @memoize Dict f(x) = ...           # with custom cache type
    @memoize LRU(maxsize=4) f(x) = ... # with another custom cache type
    @memoize (x::Foo)(y) = ...         # memoize a callable (w.r.t. both x and y)
    f(x) = @memoize g(y) = ...         # memoize a closure (w.r.t y, and x if its used)
    @memoize h(2)                      # memoize a call to any Julia function

When applied to a function definition, memoize a function, closure, or
callable, with respect to all of its arguments and keyword arguments.
When applied to a function call, memoize just that function call
(works with any Julia function).

Memoized closures or callables are memoized on a per-instance basis,
so closures are free to use the closed over variables and callables
are free to use the fields of the callable object.

By default, an IdDict is used as a cache. Any dict-like object can be
used by passing a type or an expression to construct the object as the
first argment to the macro before the function definition. For
example, if you want to memoize based on the contents of vectors, you
could use a `Dict`.
"""
macro memoize(ex1, ex2=nothing)
    cache_constructor, func_call_or_def = ex2 == nothing ? (IdDict, ex1) : (ex1, ex2)
    cache_constructor_expr = QuoteNode(Base.remove_linenums!(cache_constructor))
    # if cache_constructor is a call, wrap it in a () -> ...to make it a callable
    if isexpr(cache_constructor, :call)
        cache_constructor = :(() -> $cache_constructor)
    end
    if isexpr(func_call_or_def, :call)
        _memoize_funccall(cache_constructor, func_call_or_def)
    else
        _memoize_funcdef(cache_constructor, cache_constructor_expr, func_call_or_def)
    end
end


function _memoize_funcdef(cache_constructor, cache_constructor_expr, funcdef)
    sdef = splitdef(funcdef)
    # give unnamed args placeholder names
    sdef[:args] = map(sdef[:args]) do arg
        sarg = splitarg(arg)
        combinearg((sarg[1] == nothing ? gensym() : sarg[1]), sarg[2:end]...)
    end
    # give anonymous function placeholder name
    if !haskey(sdef, :name)
        sdef[:name] = gensym()
    end
    args   = [(issplat ? :($arg...) : arg)          for (arg,_,issplat) in map(splitarg,sdef[:args])]
    kwargs = [(issplat ? :($arg...) : :($arg=$arg)) for (arg,_,issplat) in map(splitarg,sdef[:kwargs])]
    
    # if memoizing just `f(x) = ...` we want to call both `get_cache` and
    # `empty_cache` on `f`, but if memoizing a callable like
    # `(x::Foo{T})(args...) where {T} = ...`, we want to call get_cache on `x`
    # but empty_cache on `Foo{T} where {T}`
    if isexpr(sdef[:name], :(::))
        length(sdef[:name].args)==1 && pushfirst!(sdef[:name].args, gensym())
        cacheid_get   = sdef[:name].args[1]
        cacheid_empty = :($(sdef[:name].args[2]) where {$(sdef[:whereparams]...)})
    else
        cacheid_get = cacheid_empty = sdef[:name]
    end
    
    # the body of the function definition is replaced with this:
    sdef[:body] = _memoized_call(cache_constructor, cacheid_get, sdef[:body], args, kwargs)

    quote
        func = Core.@__doc__ $(esc(combinedef(sdef)))
        begin
            # verify we haven't already memoized this function with a different cache type
            local cache_constructor_expr′ = _get!(()->$cache_constructor_expr, cache_constructor_exprs, func)
            if cache_constructor_expr′ != $cache_constructor_expr
                error("$func is already memoized with $cache_constructor_expr′")
            end
        end
        if statically_memoizable(typeof(func))
            # if it doesnt exist yet, define a get_cache specific to
            # `func`. by using a @generated function which directly
            # returns the cache, this effectively causes the cache lookup to
            # be done at compile time
            if (
                which($Memoization._static_get_cache, Tuple{typeof(func)}) == 
                which($Memoization._static_get_cache, Tuple{Any})
            )
                @eval @generated function $Memoization._static_get_cache(::typeof($(Expr(:$,:func))))
                    ($cache_constructor)()
                end
            end
            # since here we know this is a top-level function
            # definition, we also need to clear the cache (if it
            # exists) as existing memoized results may have been
            # invalidated by the new definition
            $empty_cache!($(esc(cacheid_empty)))
        end
        func
    end
end


function _memoize_funccall(cache_constructor, funccall)
    funcname = funccall.args[1]
    args, kwargs = [], []
    for arg in funccall.args[2:end]
        if isexpr(arg, :kw)
            push!(kwargs, Expr(:(=), arg.args...))
        elseif isexpr(arg, :parameters)
            push!(kwargs, arg)
        else
            push!(args, arg)
        end
    end
    esc(_memoized_call(cache_constructor, funcname, funccall, args, kwargs))
end


function _memoized_call(cache_constructor, cacheid_get, getter_body, args, kwargs)
    T, getter, cache = gensym.(("T","getter","cache"))
    quote
        $cache = $get_cache($cache_constructor, $cacheid_get)
        ($getter)() = $getter_body
        $T = $(Core.Compiler.return_type)($getter, $Tuple{})
        $_get!($getter, $cache, (($(args...),), ($(kwargs...),))) :: $T
    end
end


_get!(args...) = get!(args...)
if VERSION < v"1.1.0-DEV.752"
    # this was only added in https://github.com/JuliaLang/julia/commit/7ba6c824467d2df51db6e091bbfc9e821e5a6dc2
    function _get!(default::Base.Callable, d::IdDict{K,V}, @nospecialize(key)) where {K, V}
        val = get(d, key, Base.secret_table_token)
        if val === Base.secret_table_token
            val = default()
            setindex!(d, val, key)
        end
        return val
    end
end






fn(i) = (println("i $i 2");i)
gn() = begin
	f=5
	g=5
	println(@macroexpand @memoize  fn(f))
	println(@memoize  fn(g))
end
# cn() = begin
# 	f=5
# 	g=5
# 	println(@memoize  fn(f))
# 	println(@memoize  fn(g))
# end

gn()
# cn()

#%%
fn(a)=a+9+3f0
Core.Compiler.return_type(fn, Tuple{Float64})

#%%
using Test 
@inferred gn()
#%%
@code_warntype gn()










#%%
fn(i,j) = 5+2
fn(3,4)
@memoize fn(3,4)
#%%




struct Cache{K,V}
	c::Dict{K,V}
end
# Returns the name of the type as Symbol
function typename(typedef::Expr)
	if typedef.args[2] isa Symbol
			return typedef.args[2]
	elseif typedef.args[2].args[1] isa Symbol
			return typedef.args[2].args[1]
	elseif typedef.args[2].args[1].args[1] isa Symbol
			return typedef.args[2].args[1].args[1]
	else
			error("Could not parse type-head from: $typedef")
	end
end
macro cachelayer(key_type, typedef) 
	tn = typename(typedef)
	tn_cached = Symbol("$(tn)_cached")
	obj=:obj
	uniquekey=:uniquekey
	is_cached=:is_cached
	load=:load
	load_data=:load_data

	load_data_unimp_msg = "load_data(obj::$tn) is unimplemented cache layer interface method"
	uniquekey_unimp_msg = "uniquekey(obj::$tn) is unimplemented cache layer interface method"
	# println(tn)
	# println(tn_cached)
	return esc(quote 
		$typedef
		# esc(tn)=Dict()
		$(tn_cached)=Dict{$((key_type)),$((tn))}()

		$is_cached($obj::$tn) = $(uniquekey)($obj) in keys($tn_cached) 
		$load($obj::$tn)      = if $is_cached($obj); return $tn_cached[$(uniquekey)($obj)]
																				else                 return $tn_cached[$(uniquekey)($obj)] = $load_data($obj)
																				end
		
		$uniquekey($obj::$tn) = error($uniquekey_unimp_msg)
		$load_data($obj::$tn) = error($load_data_unimp_msg)
	end)
end

println(@macroexpand @cachelayer Tuple{Int,Int} struct QWER
 c
end)
@cachelayer Tuple{Int,Int} struct QWER
 c
end

@show QWER
@show QWER_cached
q=QWER(3)
load(q)

#%%
using Memoization
fn(i) = (println("i $i 2");i)
gn() = begin
	println(fn(5))
	println(@edit @memoize Dict{Int,Int} fn(5))
	println(@memoize Dict{Int,Int} fn(5))
	println(@memoize Dict{Int,Int} fn(5))
end

gn()
@code_warntype gn()

#%%
mutable struct QWERR
	i
	j
	c
end
key =("fefe", 3, 2)
@cache key  QWERR
QWERR_cached::Dict{typeof(key),QWERR} = Dict{typeof(key),QWERR}()
QWERR_cache_enabled::Bool             = true
get(key) = key in QWERR_cached && QWERR_cache_enabled && return ; return load_data()
$load_data($obj::$tn) = error($load_data_unimp_msg)

#%%
using Memoize
mutable struct QWERR
	i
	j
	c
end
@memoize QWERR("fefe", 3, 2)
#%%

mutable struct ASDF
	i::Int
	j::Int
	o::Matrix{Float32}
end
ASDF_cached = Dict{Tuple{Int,Int},ASDF}()
is_cached(obj::ASDF) =  uniquekey(obj) in keys(ASDF_cached)
load(obj::ASDF)      =  if is_cached(obj); return ASDF_cached[uniquekey(obj)]
												else               return (ASDF_cached[uniquekey(obj)] = load_it(obj))
												end

uniquekey(obj::ASDF) = size(obj.o)
load_it(obj::ASDF)   = (obj.o = randn(Float32,i,j); obj)

i,j=3000,4000
a=ASDF(i,j,Matrix{Float32}(undef,0,0))


@time load(a)
@time load(a)
@time load(a)


# store()

# empty!() = @assert false "unimplemented empty!!"

#%%
using LRUCache

lru = LRU{Tuple{Int,Int}, ASDF}(maxsize=4)
lru[i,j] = a


#%%
ntup=(;p=5,e=ones(3),h=ones(3,4),q=ones(7))
fn() = begin
	for (k) in values(ntup)
	println(ntup)
	end
	# println(ntup.q)
# r,t,z=randn(10000,100),randn(10000,100),randn(10000,100)
# @time o=(;e=randn(10000,100),zz=randn(10000,100),z=randn(10000,100))
# @time p=(;r,t,z)
# @time ő=(;r,t,z)
# @time o=(;u=r,w=t,z)
# @time l=(;u=r,w=t,z)
# @time ú=(;p)
# @time é=(;p...)
# @time ű=(;r=p.r,u=l.u)
end
fn()
@code_warntype fn()
# ntup=(;p=5,e=ones(3),é=ones(3,4),q=ones(7))
@code_warntype fn()
#%%
#%%